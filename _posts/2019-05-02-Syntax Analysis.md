---
layout:	post
title:	"Syntax Analysis"
image:	''
date:	2019-05-02 22:21:28
tags:	
- Exam
description: 'My life for pass!'
categories:
- Compilation Principle
---

<script type="text/javascript" src="../MathJax/MathJax.js?config=default"></script>
# 文法

## 文法概述

- 文法能清晰地描述程序设计语言的语法构成，易于理解。
- 文法能构造有效的语法分析器，检查源程序是否符合语言规定的语法形式。
- 文法定义可以了解程序设计语言的结构，有利于将源程序转化为目标代码及检查出语法错误。
- 基于文法实现的语言易于扩展。

### 文法的形式化定义

文法G定义为四元组$$(V_T,V_N,S,P)$$

* $$V_T$$是有限的终极符集合
* $$V_N$$是有限的非终极符集合
* S是开始符，$$S∈ V_N$$
* P是产生式的集合，且具有下面的形式：$$α→β，其中α，β∈(V_T∪V_N)^*$$

### 文法分类

- 0型文法：也称为短语文法，其产生式具有形式:  α→β，其中α,β∈(VT∪VN)*，并且α至少含一个非终极符 。
- 1型文法：也称为上下文相关文法。它是0型文法的特例，要求|α| ≤ |β| (S→ε例外，但S不得出现于产生式右部)。
- 2型文法：也称为上下文无关文法。它是1型文法的特例，即要求产生式左部是一个非终极符: A→β 。
- 3型文法：也称为正则文法。它是2型文法的特例，即产生式的右部至多有两个符号，而且具有下面形式之一:   A →a，A →aB|Ba 	其中A,B∈VN ，a∈VT 。 

## 文法相关概念

- 推导（直接推导）：如果A→β是一个产生式，则有αAγ⇒αβγ ,其中⇒表示一步推导。这时称αβγ是由αAγ直接推导的。
- 句型：如果有S⇒* β ，则称符号串β为CFG的句型。我们用SF(G)表示文法G的所有句型的集合。
- 句子：如果β只包含终极符，则称β为CFG的句子。
- 语言：L(G)={u| S ⇒+ u ,u ∈ VT* }文法G所定义的语言是其开始符所能推导的所有终极符号串(句子)的集合。 
- 最左（右）推导：如果进行推导时选择的是句型中的最左(右）非终极符，则称这种推导为最左(右)推导，并用符号⇒lm（⇒rm）表示最左（右）推导。
- 左（右）句型：用最左推导方式导出的句型，称为左句型，而用最右推导方式导出的句型，称为右句型(也称为规范句型)。
- 短语：设S是文法的开始符，απβ是句型(即有S ⇒* απβ），如果满足条件：S⇒* αAβ，A⇒+ π则称π是句型απβ的一个短语。
- 直接短语（简单短语）：如果满足条件：S⇒* αAβ		A⇒ π则称π是句型απβ的一个简单短语。
- 句柄：一个句型可能有多个简单短语，其中最左的简单短语称之为句柄。 
- 语法分析树(简称分析树)用来描述句型的结构，是句型推导的一种树型表示。给定文法 G=(VN,VT,S,P)，则称满足下面条件的树为G的一棵语法分析树：
  1. 每个结点都有G的一个文法符号，并且根结点标有初始符S，非叶结点标有非终极符，叶结点标有终极符或非终极符或ε。
  2. 如果一个非叶结点A有n个儿子结点(从左到右）为  X1,X2,...,Xn，则G一定有产生式 A→X1X2...Xn。
- 线性推导：称用⇒符号进行的推导为线性推导 。
- 树型推导与线性推导的不同：线性推导指明了推导的顺序，而树型推导则没有指明推导的顺序。因此，句型一般只有一棵分析树(如果无二义性)，而句型的一颗分析树则可以对应很多线性推导。
- 二义性文法：如果一个文法的某个句型有两棵不同的语法分析树，则称该文法为二义性文法。

## 文法的等价变换

### 消除开始符在产生式右侧的出现

* 定理：对任一文法G1都可以构造文法G2，使得L(G1)=L(G2)，且G2的开始符唯一且不出现于任何产生式的右部。
* 证明：假设S是G1的开始符，则只要在G1中扩充一条新产生式Z→S即可，其中Z是新的开始符。另这样扩充后的文法为G2，则它显然满足定理的要求。

### 消除空产生式

* 定理：对任一文法G1，可构造文法G2，使得L(G1)=L(G2)，且G2中无空产生式。

* 证明：根据G1，构造G2的方法如下：

  1. 令G2=G1；

  2. 令β={A | A→ε}，β=β∪{A | A⇒+α,α∈β+}；

     对于文法中任意产生式

     A→X1X2…Xi-1XiXi+1…Xn,若Xi∈β，补充规则

     A→X1X2…Xi-1Xi+1…Xn；

     重复2，直到不补充新的产生式。

  3. 从G2.P中删除所有形如A→ε的产生式。

  4. 从G2.VN删除只能导出空串的非终极符。

### 消除不可达产生式

* 定理：对任一文法G1都可以构造文法G2，使得L(G1)=L(G2)，且G2中的每个非终极符必出现在它的某个句型中。
* 证明：根据G1，构造文法G2的方法如下：
  1. 令G2=G1。
  2. 令β={S | S是文法的开始符}，递归扩充β β=β∪{B | A→xBy∈G1, B∈VN, A∈β}。
  3. 若A∉β，则删除以A为左部的所有产生式。

### 消除特型产生式

* 定理：对任一文法G1，可以构造文法G2，使得L(G1)=L(G2)，且在G2中没有特型产生式。
* 证明：构造无特型产生式的文法G2的方法如下：
  1. 对文法G1中任意非终极符A，求集合 βA={B | A⇒+B, B∈VN}。
  2. 若B∈βA，且B→α是文法G中的一个非特型产生式，则补充如下规则A→α。
  3. 去掉文法G1中的所有的特型产生式。
  4. 去掉新的文法中的无用产生式。

### 消除公共前缀

* 某个非终极符A有如下的两个产生式：A→αβ，A→αγ。称这两个产生式有公共前缀。

* 方法：对于产生式：A→αβ1|αβ2|… |αβn|γ ，其中γ表示不以α开头的字符串，引进非终极符A’，使产生式替换为：

  A → α A′ | γ 

  A′ → β1|β2 |…| βn

### 消除左递归

* 一个文法含有下列形式的产生式时：
  1. A→Aα|β，其中A∈VN；α,β ∈(VN∪VT)*
  2. A→Bα|β		B→Aγ|η       其中A,B ∈VN； α,β,γ,η∈ (VN∪VT)*
  3. 1称为直接左递归，2称为间接左递归，即文法中只要有A⇒+A…，则称文法为左递归的。
* 对于不含回路或空产生式，消除左递归方法为：
  1. 对直接左递归形如：A→Aα|β消除左递归得：A→βA′，A′→αA′|ε
  2. 间接左递归形如：A→Bα|β，B→Aγ|η消除左递归得：转为直接左递归形式：A→Aγα|ηα|β 或者 B→Bαγ|βγ|η按照直接左递归方式消除。去掉多余的产生式。

### 消除二义性

# 自顶向下分析方法

## 简介

* 基本思想：从文法开始符出发试图推导出所给的终极符串。

## 三个重要集合

### First集

- 定义：设G=(VT，VN，S，P)是CFG, α∈(VT∪VN)*，则字符串α的First集：**First(**α**)****={a**∈**VT|**α⇒***** **a**…**}**∪**{**ε**|**α⇒***** ε**}**
- “首符”——符号串α经过推导能够得到的首个终极符
- 作用：可以根据当前的输入符号是属于哪个产生式右部的首符集而决定选择相应产生式进行推导。 

#### 计算

对一文法符号X计算First(X)

- 若X∈VT, First(X)={X}

- 若X∈VN, First(X)={a| X→a…∈P,a∈VT}

- 若X∈VN,且有产生式X→ε,则 ε∈ First(X)

- 若X∈VN,有产生式X→Y1Y2…Yn，对于所有前k个字符Ym都满足Ym∈VN，(m=1,…,k;1**≤**k<n)且Ym⇒* ε，则First(Ym) -{ε}和First(Yk+1)都在First(X)中

- 若符号串α=X1X2…Xn，

  - 当X1,X2,…Xi-1⇒*ε，但是Xi不能 ⇒*ε，则First(α)=∪1i-1First(Xj)∪First(Xi)-{ε}

  - 若所有Xi都能⇒*ε，则First(α)= ∪1nFirst(Xj)

### Follow集

- 定义：设G=(VT，VN，S，P)是CFG，A∈VN，S是开始符号，则非终极符A的Follow集：Follow(A)={a∈VT|S⇒+…Aa…}∪{#|S⇒*…A}
- “跟随符”——非终极符A在推导过程中可能跟随在其后面的终极符
- 作用：当文法中存在产生式形如：A→ε时，如果当前的字符属于Follow(A)，则可以用空串取代A的出现。

#### 计算

1. 对所有B∈VN，令Follow(B)={}；对开始符S,令Follow(S)={#}； 
2. 若有产生式A→xBy，如果ε∉First(y) 则：Follow(B)=First(y)否则Follow(B)=Follow(A)∪First(y)－{ε}
3. 重复2，直至对所有B∈VN，Follow(B)收敛为止。

### Predict集

- 定义：设G=(VT，VN，S，P)是CFG，A∈VN，A→β∈P，则规则A→β的Predict集：

  Predict(A→β)=First(β),当ε∉First(β)Follow(A)∪First(β)-{ε},当ε∈First(β)

- “预测符”——产生式A→β能推导出的第一个终极符

### 使用条件

- 产生式A→β被选择的条件是：当前的输入符属于predict(A→β)。
- 至多一个产生式被选择的条件是：若k≠j predict(A→βk)∩predict(A→βj)=∅

## 递归下降分析方法

对每个非终极符按其产生式结构产生相应语法分析子程序。遇到终极符执行匹配命令(并读入下一token)；遇到非终极符则执行调用命令；文法递归相应子程序也递归，所以称这种方法为递归子程序方法/递归下降法。

### 算法

当产生式形如:A->β1|β2|…|βn,则按下面的方法编写子程序A：

```pascal
procedure A( )

begin 	if token∈Predict(A→β1) then θ(β1) else

        if token∈Predict(A→β2) then θ(β2) else

        ……

        if token∈Predict(A→βn) then θ(βn) else

        err( )

end
```

其中对βi=X1X2…Xn，θ(βi)=θ'(X1);θ'(X2);…;θ'(Xn);

如果X∈VN，θ'(X)= X();  

如果X∈VT，θ'(X)= Match(X); //即if(token==X)ReadToken();

如果X= ε，θ(ε) = skip(空语句).

## LL1分析方法

### LL分析方法概述

- LL(1)是LL(k)的特例,其中的k则表示向前看k个符号。 

- LL(1)方法和递归下降法属于同一级别的自顶向下分析法，但有一些区别。 

- - 递归下降法对每个非终极符产生子程序，而LL(1)方法则产生LL分析表；
  - 递归下降法能判断每个产生式的结束，而LL(1)方法则不能；
  - 递归下降法分析法不用符号栈，而LL(1)方法则用符号栈。

#### LL(1)分析法的适用条件

对于任一非终极符A，其任意两个产生式A→α和A→β，都要满足下面条件：
$$
Predict(A→α)∩Predict(A→β)=∅
$$
满足这一条件的文法称为LL(1)文法。可用LL（1）分析法进行语法分析。

### LL驱动算法

1. 初始化： Stack=#；Push(S)；

2. 读下一个输入符： Read(a)；

3. 若当前格局是(#, # )，则成功结束；否则转下；

4. 设当前格局为（ X....., a.....)，则

   若 X∈VT且X==a 则{Pop(1)；Read(a)；goto 3 }

   若 X∈VT且X≠a 则 Error；

   若 X∈VN，则：

   ```
   if  T(X,a)=X→Y1Y2 … Yn
   then {Pop(1)；Push(Yn,.....,Y1)；goto 3}
   else  Error
   ```

### 非LL(1)文法的处理

- BL语言{ [i ]j | i ≥j ≥ 0 }不是LL文法

- 条件语句的产生式是无法变换成LL(1)型产生式的。

  S→if id then S ELSE

  ELSE→else S|ε

- 处理方案：修改语法分析的驱动程序

- - 指定优先级
  - 指定产生式规则

# 自底向上分析方法

## 简介

- 思想：从待分析的符号串开始，自左向右进行扫描，自下而上进行分析，通过反复查找当前句型的句柄，并使用产生式规则将找到的句柄归约为相应产生式的左部非终极符，直到将输入串归约为文法的开始符。(移入-归约分析)

## LR分析方法

### 定义

- 规范句型：用最右推导导出的句型(也称右句型）。 
- 规范前缀：若存在规范句型αη，且η是终极符串或空串，则称α为规范前缀。 
- 规范活前缀：若规范前缀α不含句柄或含一个句柄并且具有形式α=α′π(π是句柄)，则称规范前缀α为规范活前缀(简称活前缀）。 
- 归约规范活前缀：若活前缀α是含句柄的活前缀，即有α=α′π，且π是句柄，则称活前缀α为归约规范活前缀（简称归约活前缀）。
- 活前缀的描述性定义：形成可归前缀之前，包括可归前缀在内所有规范句型的前缀都称为活前缀。
- 活前缀 为一个或若干规范句型的前缀。它是规范归约过程中的任何时刻已分析过的部分，即在分析栈（符号栈）中的符号串均为规范句型的活前缀，表明输入串的已被分析过的部分是该文法某规范句型的一个正确部分。
- LR(0)项目：若A→αβ是产生式，则称A→αïβ为LR(0)项目(简称项目），也写作αïβ形式。
- 项目集的投影：假设IS是LR(0)项目集，则称下面IS(X) 为IS关于X的投影集：IS(X) = {A→αXïβ |A→αïXβ∈IS, X∈(VT∪VN)}.
- 项目集的闭包：假设IS是LR(0)项目集，则称下面CLOSURE(IS)为IS的闭包集：CLOSURE(IS)= IS ∪ {A→ïπ | Y→βïAη∈CLOSURE(IS)  A→π是产生式 }

### 派生定理

- 开始符产生式的右部是归约活前缀。

- 如果αAβ是归约活前缀，且A→π是产生式，则απ也是归约活前缀。

- 任何归约活前缀，都可按上述方式被派生。

- 设文法开始符的产生式是：S→α1|α2|**…**|αn

  则文法G的可归活前缀集合为：RPSG={α1,**…**,αn}∪{απ|αAβ∈RPSG,A→π∈P}

### 构造LR（0）活前缀状态机

- 构造初始状态IS0：IS0=CLOSURE({Z→ïS})，标为NO。

- 从已构造的LRSM0部分图选择被标为NO的任一状态IS，

- 对每个符号X∈VT∪VN，完成如下步骤：

- 1. 求转换项目集合：令ISj = CLOSURE(IS(X))。
  2. 确定转换目标：初始化下标变量m；若当前LRSM中已有ISk与ISj有相同项目集，则令m=k；否则构造ISj的状态点ISj，并给ISj标上NO，同时令m=j。
  3. 在IS和ISm之间画有向X边：IS → ISm  。

- 给IS标上OK。

* 重复上一步骤至没有被标记为NO的状态结点为止。

#### LRSM0性质

- LRSM给出了所有的可归活前缀

- LRSM中的每个状态将对应一个饱和项目集： 

  1. 其中一部分是由先驱状态分出来(称为基本项目)； 
  2. 一部分则是由基本项目扩展出来的(称为扩展项目或派生项目)。派生部分项目的特点是其中的**“**ï**”**出现在产生式右部的最左侧。

- 形如A→π**•**  的项目称为归约型项目

- 形如A→α**•**β 的项目称为移入型项目

- LRSM不能直接用于LR分析

- - 自动机未标记终止状态
  - 自动机的“陷阱”状态不表示分析成功

- LRSM提供的信息：

  1. 合法性检查信息[A→αïaβ] 
  2. 移入/归约信息 [A→αïaβ]\[A→πï] 
  3. 移入/归约后的转向状态信息

### 分析表

- Action表：行代表状态，列代表输入符，而表元素则表示相应的分析动作：Shift / Reduce / Accept / Error 
- Goto表：行代表状态，而列则代表语法符号（非终极符，终极符），而表元素则表示移入或归约后的转向状态。

#### LR(0)分析表的构造

假设ISk为LR(0)项目集，则 

- 若A→αïaβ∈ISk，且GO(ISk, a)= ISi，a∈VT，则Action(ISk, a)=Si，表示把状态ISi和展望符a入栈。
- 若A→αï∈ISk，则对任意a∈VT∪{#}，令action(ISk, a)=Rj，其中产生式A→α的编号为j，表示用编号为j的产生式进行归约。
- 若Z→αï∈ISk，且Z为拓广产生式的左部非终极符，则Action(ISk, #)=Accept，表示分析成功。
- 若GO(ISk, A)=ISi，A∈VN，则Goto(ISk, A)=i。
- 其它情形，则Error(n)，表示分析出错（n：类型）。

### 驱动程序

- 置状态栈、符号栈和输入流的开始格局为：（IS0,#,a1a2…am#）
- 若当前格局为（IS0IS1IS2…ISn,#X1X2…Xn,aiai+1…am#），且Action(ISn,ai)=Sj，ai∈VT，则ai移入符号栈，第j个状态ISj移入状态栈。即移入后的格局变为：（IS0IS1IS2…ISnISj,#X1X2…Xnai,ai+1…am#）
- 若当前格局为（IS0IS1IS2…ISn,#X1X2…Xn,aiai+1…am#），且Action(ISn, a)=Rj，a∈VT∪{#}，则按照第j个产生式进行归约，符号栈和状态栈相应元素退栈，归约后的文法符号入栈。假设第j个产生式为A→α，k=|α| (α=Xn-k+1…Xn)，则归约后的格局变为：（#IS0IS1IS2…ISn-kIS,#X1X2…Xn-kA,aiai+1…am#） 其中IS=Goto(ISn-k, A)。
- 若状态栈的栈顶状态为ISi，输入流当前值为#，且action(ISi, #)=Accept，则分析成功。
- 若状态栈的栈顶状态为ISi，输入流当前值为a，且action(ISi, a)=Error或空，则转向出错处理程序。

## SLR（1）

### LR(0)分析方法的不足

- LR(0)方法对文法的要求严格。
- LR(0)方法容易出现冲突状态。
- 移入－归约冲突：项目集中同时包括移入项和归约项
- 归约－归约冲突：项目集中同时包括两个或以上的归约项

### SLR(1)分析条件

LRSM0中存在着状态 { A1 →α1ï，…，An →αnï，B1→β1 ïa1r1，…，Bm→β mïamrm}则集合：Follow(A1)、…、Follow(An)、{a1,…,am} 两两之间互不相交。

### SLR(1)分析表的构造

假设ISk为LR(0)项目集，则

- 若A→αïaβ∈ISk，且GO(ISk, a)= ISi，a∈VT，则action(ISk, a)=Si，表示把状态ISi和展望符a入栈。
- 若A→αï∈ISk，则对任意a∈VT，a∈Follow(A)，令action(ISk, a)=Rj，其中产生式A→α的编号为j，表示用编号为j的产生式进行归约。
- 若Z→αï∈ISk，且Z为拓广产生式的左部非终极符，则action(ISk, #)=Accept。
- 若GO(ISk, A)=ISi，A∈VN，则goto(ISk, A)=i。
- 其它情形，则Error(n)，表示出错标志，也可不填。

### SLR(1)文法定义

- 对于一个文法，若按照上述算法构造的分析表中没有冲突动作，则称该文法为SLR(1)文法。
- 从定义可以看出SLR(1)分析方法是用LR(0)项目构成的LRSM0来识别活前缀，因此它们的状态数相同，但是，由于LR(0)方法只看状态栈的内容而SLR(1)方法还要向前看展望符，因此SLR(1)文法要比LR（0）文法广。

### SLR(1)驱动器

- 初始格局(IS0,	#,	a1a2…am#)
- 若当前格局为 (IS0IS1…ISn,	#X1X2…Xn, aiai+1…am#)，则
  * 若action(ISn, ai)=Sk，则当前格局变为：(IS0IS1…ISn ISk,	#X1X2…Xnai, ai+1…a#)
  * 若action(ISn, ai)=Rp，则当前格局变为：(IS0IS1…ISn-kIS’,#X1X2…Xn-kA, aiai+1…am#)其中第p条产生式左部为A，goto(ISn-k, A)=IS’
  * 若action(ISn, ai)=Accept，则成功;
- 其它情形，出错。 

### SLR(1)与LR(0)

- SLR(1)和LR(0)具有相同的状态机
- LR(0)只看分析栈的内容，不考虑当前输入符；SLR(1)考虑输入符，用follow集来解决冲突，因此SLR(1)要比LR(0)分析能力强。

## LR（1）

- LR(0)方法不依赖输入流，直接判定归约，容易出现冲突。
- SLR(1)方法简单的把非终极符的follow集做为可归约的依据，并不精确。
- 一个非终极符在不同的位置上出现，它所允许的后继符是不同的。LR(1)针对不同产生式上的非终极符，分别定义其后继符集（展望符集Reducelookup），减少了移入/归约冲突。

### LRSM1的构造算法

1. 初始项目集：IS0=CLOSURE({ [Z → ïS,{ # } ]})
2. 若所有状态都处理完，则结束
3. 选一未处理完状态IS，对所有语法符号X∈（VT∪VN ∪{#}),求ISX,令IS**’** = CLOSURE(ISX)，若IS**’**不为空：若IS**’**为新状态，则增加IS       IS**’**,把IS**’**加入LRSM1中；否则为图中某个状态ISj，则在IS和ISj之间增加一条转换边：IS        ISj
4. 转到步骤2

### LR(1) 分析表的构造

假设ISk为LR(1)项目集则：

- 若[Z→αï, #]∈ISk，且Z为拓广产生式的左部非终极符，则action(ISk, #)=Accept。
- 若[A→αï, a]∈ISk，且产生式A→α的编号为j，则action(ISk, a)=Rj，表示用编号为j的产生式进行归约。
- 若[A→αïaβ, b]∈ISk，且GO(ISk, a)=ISi，a∈VT，则action(ISk, a)=Si，表示把状态ISi和展望符a入栈。
- 若GO(ISk, A)= ISi，A∈VN，则goto(ISk, A)=i。
- 其它情形，则Error(n)，表示出错标志，也可不填。

### LR(1)文法的定义

对于一个文法，若按照上述算法构造的分析表中没有冲突动作，则称该文法为LR(1)文法。

### LR(1)驱动程序

LR(1)的驱动程序与SLR(1)的驱动程序是相同的，可共用一个。

## LALR(1)

- 它具有SLR(1)的状态数少的优点和LR(1)的适用范围广的优点。 
- LALR(1)方法的功能介于SLR(1)和LR(1)之间。
- LALR(1)状态机的状态个数和LR(0)状态机的状态个数相同，而其展望符则即不采用SLR(1)的Follow集方法，也不采用LR(1)的完全精确法。

### LALR(1)的思想来源

- LR(1)状态机和LR(0)状态机从它们所表示的自动机角度来看是等价的 ；
- 自动机可以通过合并等价状态来减少状态个数，达到简化的目的。 
- 那么问题是状态机中哪些状态等价呢？
- 在LR(1)状态机出现很多同心状态，而LALR(1)状态机则不产生同心的状态，从而大大减少状态数，这就是LALR(1)和LR(1)的主要差别。 

### LALR(1)状态机的定义方式

* 用LR(1)状态机来定义；
* 用LR(0)状态机来定义。

### LALR(1)状态机的构造方法

* 先构造LR(1)状态机，后构造LALR(1)状态机，按LR(1)状态机的方式构造，但发现同心状态时不产生新状态，而是采用合并状态的方法。
* 先构造LR(0)状态机，而后用传播方式求出每个项目的展望符集。（考试不要求）

### 相关的术语

假设[A → αïβ, b]是LR(1)项目，则称其中的LR(0)项目部分A→αïβ为该**项目的心**。如果LR(1)状态机中的两个状态具有相同的心，则称它们为**同心状态**。

- 若原LR(1)状态机中无冲突，则合并同心状态后，可能产生归约--归约冲突，但是不可能产生移入--归约冲突。
- 如果合并同心状态后得到的LALR(1)状态机中没有冲突，则称其文法是LALR(1)文法。
- 如果已构造出文法的LALR(1)状态机，则LALR(1)分析表的构造算法和LR(1)分析表的构造算法一样 。

## LR方法小结

- 从功能上看，各种语法分析方法的分析能力从小到大依次为：LR(0)<SLR(1)<LALR(1)<LR(1)
- 从状态数方面看，各种语法分析方法的状态数有如下关系：	LR(0)=SLR(1)=LALR(1)<LR(1)。 