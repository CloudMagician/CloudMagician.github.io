---
layout:	post
title:	"Software Engineering"
image:	''
date:	2019-06-23 15:23:28
tags:	
- Exam
description: 'My life for pass!'
categories:
- Software Engineering
---

<script type="text/javascript" src="../MathJax/MathJax.js?config=default"></script>

# 软件工程学概述

## 软件

软件是计算机系统中与硬件相互依存的另一部分，它是包括程序、数据及其相关文档的完整集合。其中：

* 程序是按事先设计的功能和性能要求执行的指令序列；
* 数据是使程序能正常操纵信息的数据结构；
* 文档是与程序开发、维护和使用有关的图文材料。

### 特点

- 抽象性；
- 没有明显的制造过程，质量控制必须着重在软件开发方面下功夫；
- 没有机械磨损、老化问题。

## 软件危机

在计算机软件的开发和维护过程中所遇到的一系列严重问题。

大体上，这些问题分为两方面：

* 如何开发软件，以满足对软件日益增长的需求；
* 如何维护数量不断膨胀的已有软件。

## 软件工程

软件工程是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。

### 本质特性

- 关注大型程序的构造

- 中心课题是控制复杂性（复杂性的来源：规模、不确定性、认知的鸿沟）

- 软件经常变化

- 开发软件的效率非常重要

- 和谐地合作是开发软件的关键

- 软件必须有效地支持它的用户

- 软件工程领域中是由具有一种文化背景的人替具有另一种文化背景的人创造产品（两个空间）

### 基本原理

1. 用分阶段的生命周期计划严格管理
2. 坚持进行阶段评审
3. 实行严格的产品控制
4. 采用现代程序设计技术
5. 结果应能清楚地审查
6. 开发小组的成员应该少而精
7. 承认不断改进软件工程实践的必要性

### 基本内容

软件工程包括管理和技术两方面的内容

### 软件工程方法学

通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学（**methodology**），也称为范型（**paradigm**）

- 软件工程方法学包含三个要素：方法、工具、过程。

#### 传统方法学

- 又称过程式方法学、生命周期方法学或结构化范型

- 采用结构化技术（结构化分析、结构化设计和结构化实现）来完成软件开发的各项任务，并使用适当的软件工具或软件工程环境来支持结构化技术的运用

- 把软件生命周期的全过程划分为若干个阶段：

  * 前一阶段是基础、前提，后一阶段是细化

  - 每一个阶段的开始和结束都有严格的标准
  - 在每一个阶段结束之前都必须进行正式严格的技术审查和管理复审

##### 优点

- 通过将软件生命周期划分成若干个阶段降低了整个软件开发过程的困难程度
- 每个阶段结束前的严格审查保证了软件的质量，提高了软件的可维护性

##### 问题

- 若软件规模庞大，或者对软件的需求是模糊的或会随时间而变化

  * 使用传统方法学开发软件往往不成功

  - 而且维护起来仍然很困难

- 问题根源：把原本密切相关的数据和操作人为地分离成了两个独立的部分，增加了软件开发与维护的难度


#### 面向对象方法学

- 面向对象方法学是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法

- 面向对象方法学的**4**个要点：

  * 把对象作为融合了数据及在数据上的操作行为的统一的软件构件

  - 把所有对象都划分成类
  - 按照父类与子类的关系，把若干个相关类组成一个类层次结构，位于下层的类继承了上层中某类的特点
  - 对象彼此间仅能通过发送消息互相联系


##### 优点

- 降低了复杂性
- 提高了可理解性
- 简化了开发和维护
- 促进了软件重用

### 软件生命周期（**Software Life Cycle**）

- 概括地说，软件生命周期由软件定义、软件开发和运行维护**3**个时期组成，每个时期又进一步划分成若干个阶段。

# 软件过程

## 软件过程与软件工程

- 软件过程：为建造高质量软件所需完成的任务的框架，它规定了完成各项任务的工作步骤。

- 软件过程和软件工程的关系：

  * 软件工程应该是由有创造力、有知识的人在定义好的、成熟的软件过程中进行的，该过程适合于他们建造的产品和他们的市场需要。

  - 软件过程定义了软件开发中采用的方法，但软件工程还包含该过程中应用的其他技术和工具。


## 经典软件过程模型

### 瀑布模型

### 原型**/**快速原型模型

### 阶段式开发（演化模型）

### 螺旋模型

### 喷泉模型

## 现代软件过程模型

### RUP ( Rational Unified Process)

#### **RUP**软件开发生命周期

##### 工作阶段

* 初始(Inception)：建立业务模型，定义最终产品视图，确定项目的范围
* 精化(Elaboration)：设计并确定系统的体系结构，制定项目计划，确定资源需求
* 构建(Construction)：开发所有构件和程序，集成为可户需要的产品，测试所有功能
* 产品化(Transition)：把开发出的产品提交给用户使用

### 敏捷过程

# 可行性研究

## 任务

### 目的

用最小的代价，在尽可能短的时间内确定问题是否能够解决。

### 实质

就是一次压缩、简化了的系统分析和设计的过程。

### 着重考虑方面

* 技术可行性：使用现有的技术能否实现这个系统。
* 经济可行性：进行成本**∕**效益分析。从经济角度判断系统开发是否**“**合算**”**。
* 操作可行性：系统的操作方式在这个用户组织内是否行得通。
* 法律可行性：确定系统开发可能导致的任何侵权、妨碍和责任。
* 开发方案的选择性研究：提出并评价实现系统的各种开发方案，并推荐较优方案。

## 系统流程图

系统流程图是概括地描绘物理系统的传统工具。它的基本思想是用图形符号以黑盒子形式描绘组成系统的每个部件。包括程序、文档、数据库和人工过程等。它表达了数据在系统各部件之间的流动情况。

# 软件需求

## 需求概述

### 功能需求、非功能需求

- 功能需求：系统与环境间的交互**——**描述系统必须支持的功能和过程的系统需求
- 非功能需求：客户给出的具体约束、指标**——**描述操作环境和性能目标的系统需求
- 二者的区别：功能需求描述系统应该做什么，非功能需求则为如何实现这些需求设定约束

### 需求的特征

* 正确性
* 一致性
* 完整性
* 可检验性
* 现实性
* 实用性
* 可回溯性

### 需求分析的任务

- 确定对系统的综合要求
- 导出系统的逻辑模型
- 修正系统的开发计划

## 需求过程

### 与用户沟通获取需求的方法

- 访谈
- 面向数据流自顶向下求精
- 简易的应用规格说明技术
- 快速建立软件原型

## 分析建模与规格说明

### 系统模型（结构化分析方法）

- 必须理解并描述问题的信息域，根据这条准则应该建立数据模型
- 必须定义软件应完成的功能，这条准则要求建立功能模型
- 必须描述作为外部事件结果的软件行为，这条准则要求建立行为模型
- 必须对描述信息、功能和行为的模型进行分解，用层次的方式展示细节

## 数据流图与数据字典

## 状态转换图

# 总体设计

## 软件设计过程

### 概要设计（总体设计）

将软件需求转化为数据结构和软件的系统结构，即系统的模块划分

### 详细设计

通过对系统的结构表示（每个模块的内部工作）进行细化，得到软件的详细的数据结构和算法

## 软件设计原理

### 模块化

- 模块：

  * 可单独命名和可编址的部分

  - 由边界元素限定的相邻程序元素的序列，而且有一个总体标识符代表它。如：**procedure, function, subroutine, block**，**Macro**

- 模块化：

  * 程序划分成独立命名且可独立访问的模块

  - 每个模块完成一个子功能
  - 把这些模块集成起来构成一个整体，可以完成指定的功能，满足用户的需求


### 模块独立性

#### 原理

* 每个模块完成一个相对独立的子功能，并且和其他模块之间的关系很简单
* 它是模块化、抽象、信息隐藏和局部化概念的直接结果

#### 理由

- 有效的模块化（即具有独立性的模块）的软件比较容易开发出来
- 独立的模块比较容易测试和维护

#### 度量独立程度的两个定性标准

- 耦合（**Coupling**）：衡量不同模块彼此间互相依赖（连接）的紧密程度
- 内聚（**Cohesion**）：衡量一个模块内部各个元素彼此结合的紧密程度

## 描绘软件结构的图形工具

### 结构图(Structure Chart ,SC)

## 面向数据流的设计方法

- 通常所说的结构化设计方法（简称**SD**方法），也就是基于数据流的设计方法 
- 面向数据流的设计方法把信息流映射成软件结构（信息流的类型决定了映射的方法）
- 信息流类型：变换流、事务流

### 基本过程

- 研究、分析和审查数据流图
- 根据数据流图决定问题的类型（信息流类型）
- 由数据流图推导出系统的初始结构图
- 根据启发规则对结构进行细化
- 修改和补充数据字典
- 制定测试计划

## 软件体系结构

软件体系结构是对子系统、软件系统构件以及它们之间相互关系的描述。

### 软件体系结构风格（**SA Styles**）

- 软件体系结构风格根据软件系统的结构定义了软件系统族，它通过施加于构件上的限制及组成与设计的规则来表现构件和构件间的关系
- 体系结构风格为一个软件系统及其建造方法提供了一种特殊的基本结构
- 软件体系结构风格限制了系统中各构件之间的连接方式
  * 指定了构件间交互模式
  * 促进了基本设计原则的落实：低耦合、高内聚

#### 顺序批处理风格

#### 管道和过滤器风格

#### 数据抽象与面向对象风格

#### 层次系统风格

#### 客户机**-**服务器风格

#### 基于事件／隐式调用风格

#### 仓库（**Repositories**）风格

#### 黑板风格

# 详细设计

## 结构程序设计

- 经典的结构程序设计：只允许使用**顺序**、**IF-THEN-ELSE型分支**和**DO-WHILE型循环**这3种基本控制结构实现单入口单出口的程序
- 扩展的结构程序设计：除了上述3种基本控制结构之外，还允许使用**DO-CASE型多分支结构**和**DO-UNTIL型循环结构**
- 修正的结构程序设计：再加上允许使用**LEAVE(或BREAK)结构**

## 过程设计技术和工具

### 程序流程图

### 盒图

### PAD图

### 判定表

### 判定树

### 过程设计语言PDL

## 程序复杂程度的定量度量 

### **McCabe**方法

根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的环形复杂度

- 描绘程序控制流的流图（也称为程序图）：

  * 实质上是**“**退化了的**”**程序流程图

  - 它仅仅描绘程序的控制流程，完全不表现对数据的具体操作以及分支或循环的具体条件

  - 流图包含**3**种元素：

    * 结点：用圆表示，代表一条或多条语句

    - 边：用箭头表示，一边必须终止于一个结点
    - 区域：由边和结点围成的面积

- 有了描绘程序控制流的流图之后，可以用下述**3**种方法中的任何一种来计算环形复杂度：

- - 流图中的区域数等于环形复杂度
  - 流图**G**的环形复杂度**V(G)**＝**E**－**N+2**，其中，**E**是流图中的边数，**N**是结点数
  - 流图**G**的环形复杂度**V(G)**＝**P+1**，其中，**P**是流图中判断的数目

# 实现

## 软件测试基础

### 软件测试目标

测试是程序的执行过程，目的在于发现错误

- 一个好的测试用例在于能发现至今未发现的错误
- 一个成功的测试是发现了至今未发现的错误的测试

### 软件测试方法

#### 黑盒测试

- 已知产品应该具有的功能
- 通过测试，检验是否每个功能都能正常使用

#### 白盒测试：

- 已知模块的内部结构和算法
- 通过测试 ，检验模块内部主要执行通路是否能按预定要求正常工作

## 软件测试步骤

- 模块测试（单元测试）：把每个模块作为一个单独的实体来测试，发现的往往是编码和详细设计的错误

- 子系统测试（集成测试）：把经过单元测试的模块放在一起形成一个子系统来测试，着重测试模块的接口

- 系统测试（集成测试）：把经过测试的子系统装配成一个完整的系统来测试，发现的往往是软件设计中的错误，也可能发现需求说明中的错误

- 确认测试（验收测试）：

  * 把软件系统作为单一的实体进行测试，是在用户积极参与下进行的，而且可能主要使用实际数据（系统将来要处理的信息）进行测试

  - 目的是验证系统确实能够满足用户的需要
  - 发现的往往是系统需求说明书中的错误

- 平行运行：

  * 同时运行新系统和将被它取代的旧系统

  - 比较新旧两个系统的处理结果

  - 这样做的具体目的有如下几点：

    * 可以在准生产环境中运行新系统而又不冒风险

    - 用户能有一段熟悉新系统的时间
    - 可以验证用户指南和使用手册之类的文档
    - 能够以准生产模式对新系统进行全负荷测试，可以用测试结果验证性能指标


### 单元测试

#### 测试重点

1. 模块接口。主要检查下述几个方面：
   - 参数的数目、次序、属性或单位系统与变元是否一致
   - 是否修改了只作输入用的变元
   - 全局变量的定义和用法在各个模块中是否一致
2. 局部数据结构：发现局部数据说明、初始化、默认值等方面的错误
3. 重要的执行通路：选择最有代表性、最可能发现错误的执行通路进行测试
4. 出错处理通路。着重测试下述一些可能发生的错误：
   * 对错误的描述是难以理解的
   * 记下的错误与实际遇到的错误不同
   * 在对错误进行处理之前，错误条件已经引起系统干预
   * 对错误的处理不正确
   * 描述错误的信息不足以帮助确定造成错误的位置
5. 边界条件

### 集成测试

根据集成测试的两类方法，大体上有四种集成策略：

- 一次性集成
- 自顶向下集成
- 自底向上集成
- 三明治集成

### 回归测试

- 回归测试（**regression test**）

  * 重新执行已经做过的测试的某个子集

  - 以保证由于调试或其他原因引起的变化，不会导致非预期的软件行为或额外错误

- 回归测试集（已执行过的测试用例的子集）包括下述3类不同的测试用例：

  * 检测软件全部功能的代表性测试用例

  - 专门针对可能受修改影响的软件功能的附加测试
  - 针对被修改过的软件成分的测试


### 确认测试

- 确认测试也叫验收测试，其目标是：验证软件的有效性

- 软件有效性的简单定义：如果软件的功能和性能如同用户所合理期待的那样，软件就是有效的

- 软件有效性的标准：

  * 需求阶段产生的需求规格说明书或类似文档

  - 也是进行确认测试的基础

- 确认测试以用户为主来进行

### 术语：两类不同性质的测试工作

- **Verification**：验证指的是保证软件正确地实现了某个特定要求的一系列活动（从工程师角度看问题）
- **Validation**：确认指的为了保证软件确实满足了用户需求而进行的一系列活动（从用户角度看问题）

### 软件配置复查

- 复查的目的是：

  * 保证软件配置的所有成分都齐全

  - 质量符合要求
  - 文档与程序完全一致
  - 具有完成软件维护所必须的细节，而且已经编好目录

- 在确认测试过程中应该严格遵循用户手册及其他操作程序的说明和要求，从而检验用户使用手册的完整性和正确性

### **Alpha**和**Beta**测试

针对为大量客户开发的软件

#### Alpha测试

- 由用户在开发者的场所进行
- 在开发者对用户的**“**指导**”**下进行测试
- 开发者负责记录发现的错误和使用中遇到的问题
- 总之，**Alpha**测试是在受控的环境中进行的

#### Beta测试

- 由软件的最终用户们在一个或多个客户场所进行
- 与**Alpha**测试不同，开发者通常不在**Beta**测试的现场
- 因此，**Beta**测试是软件在开发者不能控制的环境中的**“**真实**”**应用

## 测试用例设计

### 白盒测试技术

#### 逻辑覆盖

逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例的技术

##### 语句覆盖

##### 判定覆盖

##### 条件覆盖

##### 判定**/**条件覆盖

##### 条件组合覆盖

##### 点覆盖

##### 边覆盖

##### 路径覆盖

#### 控制结构测试

##### 基本路径测试

- 基本路径法用于设计测试用例，要点为：

- - 计算程序的环形复杂度
  - 用该复杂度为指南定义执行路径的基本集合
  - 从该基本集合导出测试用例

- 使用基本路径法设计测试用例可以保证：

- - 程序中的每条语句至少执行一次
  - 每个条件在执行时都将分别取真、假两种值

* 步骤：
  1. 根据过程设计结果画出相应的流图
  2. 计算流图的环形复杂度
  3. 确定线性独立路径的基本集合
     * 独立路径是指至少引入程序的一个新处理语句集合或一个新条件的路径
     * 用流图术语描述，独立路径至少包含一条在定义该路径之前不曾用过的边
     * 程序的环形复杂度决定了程序中独立路径的数量
     * 而且这个数是确保程序中所有语句至少被执行一次所需的测试数量的上界
  4. 设计可强制执行基本集合中每条路径的测试用例

##### 循环测试

- 循环测试是一种白盒测试技术，它专注于测试循环结构的有效性

- 在结构化的程序中通常只有**3**种循环：简单循环、嵌套循环、串接循环（连锁循环）


### 黑盒测试技术

黑盒测试的方法主要有：

- - 等价划分
  - 边界值分析
  - 错误推测

#### 等价划分

- 等价划分法：把所有可能的输入数据，即程序的输入域划分成若干部分（类），据此导出测试用例

- 等价划分法的一个假设：每类中的一个典型值在测试中的作用与这一类中所有其他值的作用相同

- 等价划分法背后的理念：一个理想的测试用例能够独自发现一类错误

- 在确定输入数据的等价类时，常常还需要确定输出数据的等价类，以便根据输出数据等价类导出对应的输入数据等价类

## 软件可靠性

### 估算平均无故障时间的方法

# 软件维护

## 软件维护的定义

就是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程。

### 类型

* 改正性维护（**Corrective maintenance**）
* 适应性维护（**Adaptive maintenance**）
* 完善性维护（**Perfective maintenance**）
* 预防性维护（**Preventive maintenance**）

## 软件维护过程

### 维护报告

- 维护要求表或称软件问题报告表，由申请维护的用户填写

- 软件修改报告，由软件组织内部制定，要指明：

  * 满足某个维护要求表中提出的要求所需要的工作量

  - 维护要求的性质
  - 维护要求的优先级
  - 与修改有关的事后数据


## 软件的可维护性

维护人员理解、改正、改动或改进这个软件的难易程度

### 决定软件可维护性的因素

- 可理解性
- 可测试性
- 可修改性
- 可移植性
- 可重用性

### 软件文档

1. 必须描述如何使用这个系统，没有这种描述时即使是最简单的系统也无法使用
2. 必须描述怎样安装和管理这个系统
3. 必须描述系统需求和设计
4. 必须描述系统的实现和测试，以便使系统成为可维护的

### 用户文档

1. 功能描述：说明系统能做什么
2. 安装文档：说明怎样安装这个系统、怎样使系统适应特定的硬件配置
3. 使用手册：简要说明如何着手使用这个系统
4. 参考手册：详尽描述用户可以使用的所有系统设施以及它们的使用方法，还应该解释系统可能产生的各种出错信息的含义
5. 操作员指南：如果需要有系统操作员的话，说明操作员应该如何处理使用中出现的各种情况

### 系统文档

- 系统文档指从问题定义、需求说明到验收测试计划这样一系列和系统实现有关的文档
- 描述系统设计、实现和测试的文档对于理解程序和维护程序极端重要
- 从概貌到每个方面每个特点，从抽象到具体，有逻辑地介绍系统

### 可维护性复审

- 在需求分析阶段的复审过程中

  * 应该对将来要改进的部分和可能会修改的部分加以注意并指明

  - 应该讨论软件的可移植性问题，并且考虑可能影响软件维护的系统界面

- 在正式的和非正式的设计复审期间

  * 应该从容易修改、模块化和功能独立的目标出发，评价软件的结构和过程

  - 设计中应该对将来可能修改的部分预作准备


# 软件项目管理

## 软件项目进度计划

### **Gantt**图

- **Gantt**图能很形象地描绘任务分解情况，以及每个子任务**(**作业**)**的开始时间和结束时间，因此是进度计划和进度管理的有力工具。它具有直观简明和容易掌握、容易绘制的优点

- 但是**Gantt**图也有**3**个主要缺点：

  * 不能显式地描绘各项作业彼此间的依赖关系

  - 进度计划的关键部分不明确，难于判定哪些部分应当是主攻和主控的对象
  - 计划中有潜力的部分及潜力的大小不明确，往往造成潜力的浪费


### 工程网络

- 工程网络能描绘任务分解情况以及每项活动／作业的开始时间和结束时间

- 此外，它还显式地描绘各个作业彼此间的依赖关系

- 工程网络图要求绘制者理解项目中哪些部分可以并行。活动的并行执行还取决于其执行者是否是一个人／单位


### 估算工程进度

- 首先，把每个作业估计需要使用的时间写在表示该项作业的箭头上方
- 其次，为每个事件计算下述两个统计数字：最早时刻**EET**和最迟时刻**LET**

### 关键路径（**Critical Path**）

- 关键路径：

  * 由最早时刻和最迟时刻相同的事件组成的路径

  - 在工程网络图中关键路径用粗线箭头表示

- 关键路径上的事件（关键事件）必须准时发生。组成关键路径的作业（关键作业）的实际持续时间不能超过估计的持续时间，否则工程就不能准时结束

- 使用关键路径法可以得出完成项目所需的最少时间

## 软件项目中的人员与组织结构

### 人员组织

### 民主制程序员组

### 主程序员组

### 大型项目的技术管理组织结构

## 软件项目的成本与工作量估算

### 软件规模估算的两种方法

- 代码行技术：这种方法依据以往开发类似产品的经验和历史数据，估计实现一个功能所需要的源程序行数 
- 功能点技术：看交付的软件的总功能有多少。依赖对软件信息域特性和软件复杂性的评估结果估算软件规模。功能点（**FP**）和对象点是这种估算中常用的指标

## 软件项目的风险

### 风险管理的内容

#### 风险识别

##### 软件项目的核心风险

- 进度安排的先天错误

  * 安排时间和工作量时犯下的错误

  - 对规模的判断失误、预算的彻底失败

- 需求膨胀

  * 在开发的过程当中，客户的业务领域不可能始终静止不变

  - 从项目的角度来看，需求总是向着膨胀的方向变化
  - 合理的开发逻辑应该考虑到需求变化的可能程度而在制定的计划中允许一定限度的改变

- 人员的流失

  * 掌握技术人员的年平均流动率

  - 掌握新人工作能**“**上手**”**的最短时间
  - 从而为项目分配一定的缓冲人力资源

- 规约崩溃

  * 问题的本质是在项目启动阶段商谈需求范围时没有谈拢

  - 实际操作中有可能掩盖严重的冲突，而定下一个让每一方勉强接受的含混不清的目标而开始项目
  - 直到项目明确满足规约要求时此风险才消失


#### 风险分析

#### 风险规划

#### 风险控制

## 软件项目配置管理

- 配置管理的目的是针对变化、控制变化

- 软件配置管理的目标是：

  - 标识变更

  - 控制变更
  - 确保变更正确地实现
  - 向其他有关的人报告变更
  
- 简言之，软件配置管理是软件系统发展过程中管理和控制变化的规范

### 软件配置

- 软件配置项（**Software Configuration Item**）：为了配置管理而作为单独实体处理的一个工作产品或一段软件，简称**SCI**简单说，就是软件过程输出的全部计算机程序、文档、数据

- 配置管理聚集：**SCI**的一个组合，简称**CM**聚集或配置

- 版本：在一确定的时间点上，某个**SCI**或某个配置的状态

- 基线（**baseline**）：基线就是通过了正式复审的软件配置项

- 项目数据库：一旦一个**SCI**成为基线，就被存放到项目数据库中；项目数据库和变更控制规程相结合，保护着项目的基线


# 面向对象建模基础

## UML建模简介

## 面向对象的需求提取

### 用例（**Use Case** ）

- 用例是什么：

  * 本质上，一个用例是用户与计算机之间为达到某个目的而进行的一次典型交互作用

  - 作为结果，用例代表的就是系统的一个完整功能

- 用例间的关系：包含、扩展、泛化
