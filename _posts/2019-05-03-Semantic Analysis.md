---
layout:	post
title:	"Semantic Analysis"
image:	''
date:	2019-05-03 15:02:28
tags:	
- Exam
description: 'My life for pass!'
categories:
- Compilation Principle
---

<script type="text/javascript" src="../MathJax/MathJax.js?config=default"></script>

# 语义分析

## 必要性

- 语法和语义的区别

- - 语法：关于什么样的字符串才是该语言在组成结构上合法的程序的法则。
  - 语义：关于结构上合法的程序的意义规范和约束。

- 形式语义的应用

- - 程序语言设计：自然语言不够严谨；形式化的建模是进一步分析的基础。

## 分类

- 语义种类
  * 指称语义
  * 操作语义
  * 公理语义
  * 静态语义：在编译阶段(从程序文本上)可以检查的语义。
  * 动态语义：通过程序的执行才能检查的语义。

## 典型语义错误

1. 各种条件表达式的类型是不是boolean型?
2. 运算符的分量的类型是否相容?
3. 赋值语句的左右部的类型是否相容?
4. 形参和实参的类型是否相容?
5. 下标表达式的类型是否为所允许的类型?
6. 函数说明中的函数类型和返回值的类型是否一致?

## 功能

- 语义分析的内容：

- - 类型分析；
  - 标识符相关信息提取；

- 语义分析的功能：

- - 检查语义错误
  - 构造标识符属性表（符号表）

- 语义分析的实现：

- - 与语法分析相结合

# 符号表

## 内部表示

### 标识符

#### 种类

常量名、类型名、变量名、函数名、过程名、域名。

#### 内部表示

* 常量名：

  | Name | Kind      | Type   | Value |
  | ---- | --------- | ------ | ----- |
  | M    | constKind | intPtr | ^10   |

* 变量名：

  | Name | Kind    | Type     | Acces  | Level | Off  | Value     |
  | ---- | ------- | -------- | ------ | ----- | ---- | --------- |
  | a    | varKind | floatPtr | direct | 1     | 3    | Null/^100 |

* 类型名：

  | Name | Kind     | Type |
  | ---- | -------- | ---- |
  | mat  | typeKind | Ptr  |

* 过函名：

  | Name | Kind     | Type   | Class  | Level | Off  |
  | ---- | -------- | ------ | ------ | ----- | ---- |
  | f    | funcKind | intPtr | formal | 1     | 5    |

  | Name | Kind     | Type   | Class  | paraList | ptrF  | Size | t/f     |
  | ---- | -------- | ------ | ------ | -------- | ----- | ---- | ------- |
  | f    | funcKind | intPtr | actual | pPL      | pCode | n    | Forward |

* 域名：

  | Name | Kind      | Type   | off  |
  | ---- | --------- | ------ | ---- |
  | mark | FieldKind | IntPtr | 3    |

#### 层数和偏移

- 层数(level)

- - 过程/函数的定义(不)可以嵌套；
  - 最外层程序的层数为1(0);

- 偏移量(offset)

- - 原因：执行过程/函数的调用时, 需要为其中的变量分配空间;
  - 计算：偏移量指的是变量针对其所在过程/函数的空间的首地址的偏移量;

### 类型

#### 种类

标准、子界、枚举、数组、记录、集合、文件、指针类型等

#### 内部表示：(TypeIR)

* int/bool/char/float

  | Size | Type  |
  | ---- | ----- |
  | 1    | intTy |

* enum

  | Size | Type   | ElementList | Length |
  | ---- | ------ | ----------- | ------ |
  | 1    | enumTy | elPtr       | 3      |

* array

  | Size | Type   | Low  | Up   | ElementType |
  | ---- | ------ | ---- | ---- | ----------- |
  | 5    | arryTy | 0    | 4    | intPtr      |

* pointer

  | Size          | Type      | TypeName |
  | ------------- | --------- | -------- |
  | size(pointer) | pointerTy | intPtr   |

* 结构体、类

  | Size | Kind | FieldList |
  | ---- | ---- | --------- |
  |      |      |           |

  | name | Kind | Type | Off  |
  | ---- | ---- | ---- | ---- |
  |      |      |      |      |
  |      |      |      |      |

### 值

基本类型：整型，实型

无序类型：指针，数组，结构体

有序类型：布尔，字符，枚举，数组下标

* 布尔常量：ord(false)=0, ord(true)= 1
* 字符常量：ord(C) = ASCⅡ(C)
* 枚举常量：设有枚举类型(D,A,B),则有ord(D)=0,ord(A)=1,ord(B)=2

## 符号表

- 标识符在不同位置的不同作用：

- - 声明部分：定义了各种对象及对应的属性和使用规则。
  - 程序体：对所定义的对象进行各种操作。

- 必要性

- - Token序列：
  - 符号表（种类、类型等信息）：

### 建立和访问

有关符号表的操作：添加、作用域删除、查询

处理符号表的模块：

* 定义符号表数据结构
* 定义符号表上的操作

### 符号表的处理

#### 符号表的作用

为语义检查和代码生成提供标识符的语义信息。

#### 标识符的处理思想

1. 遇到定义性标识符时，在符号表中填写被定义标识符的符号项；
2. 遇到使用性标识符时，用该标识符查符号表求得其属性。

#### 标识符的特点

- 标识符的作用域：标识符有效的最大程序段
- 嵌套作用域规则：当存在标识符的嵌套声明时，最近定义的属性为标识符的当前属性
- 局部化单位：允许有声明的程序段

#### 局部化区入口

- Proc p(…
- Func f(…
- Record begin…

#### 标识符处理的原则

1. 进入一个局部化区时，记录本层符号表的位置 
2. 遇到定义性标识符时，构造其语义信息，查本层符号表，若存在，则有重复声明错误，否则将语义信息填入表中 
3. 遇到一个使用性标识符时，查表（从里层到外层），查不到则有未定义标识符错误，否则构造新的TOKEN
4. 退出一个局部化区时，作废本层符号表

#### 符号表的分类

- 单表结构 vs. 多表结构

- - 单表：标识符都放在同一张符号表中
  - 多表：标识符表按照局部化区分别存放

- 局部表 vs. 全局表

- - 局部式：每个局部化单位建立一个独立符号表
  - 全局式：整个程序的符号表作为一个表

#### 全局符号表的局部化

|        | 思想               | 特点                                   |
| ------ | ------------------ | -------------------------------------- |
| 删除法 | 离开局部化区时删除 | 思路简单，实现容易，信息不留存         |
| 驻留法 | 离开局部化区时标记 | 信息留存，实现相对复杂（辅助数据结构） |

#### 局部符号表管理——Scope栈

- 用于存放当前有效的局部化区的局部符号表首地址；
- 进入新局部化区时新符号表首地址入栈；
- 退出局部化区时栈顶地址出栈。