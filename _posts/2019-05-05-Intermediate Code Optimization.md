---
layout:	post
title:	"Intermediate Code Optimization"
image:	''
date:	2019-05-05 15:05:21
tags:	
- Exam
description: 'My life for pass!'
categories:
- Compilation Principle
---

<script type="text/javascript" src="../MathJax/MathJax.js?config=default"></script>

# 概述

- 优化的目标

- - 提高程序执行效率

- 优化的要求

- - 有效（保证正确性前提下的效率提升）
  - 平衡（保证优化开销与执行开销的可比性）

- 优化的对象

- - 源程序（程序员——用户）
  - 中间代码（元级程序——静态分析）
  - 目标代码（元级程序——目标机导向）

# 常表达式优化

## 基本块和程序流图

基本块：单入口单出口的程序段。

程序流图：以基本块为结点的有向图，有向边表示

​             程序执行的流程。

中间代码基本块的划分：

- - 首条代码为第一个基本块的入口
  - 遇转移性中间代码时，结束当前基本块，下一条代码作为新基本块的入口
  - 遇标号性代码结束当前基本块，代码本身作为新基本块的入口。
  - 遇（ASSIG,A,n,X）时，如果X为引用型形参时结束当前块，并作为该块的出口。

## 常表达式局部优化

* 常表达式的定义：静态编译任何时候都取固定常数值的表达式
* 处理思想：针对同一基本块内部，如果一个多元式的所有分量的值已知，则计算其值，并删掉相应的中间代码。

## 基于值编码的公共表达式局部优化

- 按值等价原理
- 优化思想：对一个多元式的分量分别编码，具有相同编码的分量等价。
- 值编码表ValuNnm
- 可用表达式代码表UsableExpr
- 临时变量等价表TempEqua

### 基于值编码的优化算法

- 入口处初始化：

- - ValueNum,UsableExp和TempEqua为空。

- 对当前多元式用TempEqua等价替换，生成NewTuple.

- 如果NewTuple的A和B分量是未编码的，则编新码；

- - 如果多元式形如dk:(ω,A′,B′,tk )

  - - 若存在di∈UsableExpr使得dk是di的ECC，则删掉dk，将(tk,ti)填入TempEqua表；
    - 否则，为tk编码；把dk加入到UsableExpr表；

  - 如果多元式形如dk:(ASSIG,A′,-,B′ )

  - - 则令B′的值编码等于A′的值编码，填入ValuNum表中；从UsableExpr删除所有含B的中间代码。

# 循环不变式外提优化

- 循环的识别：识别循环的入口、重复体、出口

- 识别方法：基于程序文本，基于程序图。

- 外提对象：循环不变式

- 安全性: 

- - 除法表达式不能外提(除零溢出)
  - 赋值表达式不能外提(不一定执行该循环）

- 原理：

- - 定义LoopDef是在循环体内被定义的变量集合;
  - 对每层循环记录LoopDef;若循环体内的多元式( ω,A,B,t)中的A,B不在本层的LoopDef中,则把( ω,A,B,t)外提到循环体的入口处。

## 关键问题

- 检查循环体中哪些变量的值被改变过
- 根据这个结果来看哪些表达式是不变的表达式
- 建立变量定值表，将循环体中值被改变的变量都填到表里，若某运算型四元式中两个运算分量都不出现在这个表里，就说明其值不发生改变，可以进行外提。

## 循环不变式外提算法

- 对循环体四元式进行第一遍扫描，把有定值的变量填到变量定值表中，若它是一个运算型四元式(ω1,A1,B1,t1)，则把t1填到表中，若为赋值型四元式(=，a，-，b)则把b填入表中
- 循环不变式外提为第二遍扫描，每遇到一个运算型四元式(ω1,A1,B1,t1)，若A1、B1都不在变量定值表中，则将其提到循环体外，同时在变量定值表中删去t1

## 循环不变式外提中注意的问题

1. 多层循环问题中，一个四元式从里层开始可以被外提若干次，里层变量定值表属于外层变量定值表
2. 除法不外提
3. 赋值绝不外提
4. 函数调用不做外提优化