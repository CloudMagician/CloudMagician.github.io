---
layout:	post
title:	"Backtracking Method"
image:	''
date:	2019-01-04 13:34:01
tags:	
- Algorithm
- Exam
description: 'My life for pass!'
categories:
- Algorithm
---

<script type="text/javascript" src="../MathJax/MathJax.js?config=default"></script>

# 一般方法

- 解的形式：n元组(x1,…,xn),其中xi取自某个有穷集Si
- 规范函数(有时也称为限界函数，可以表示约束条件或目标) P(x1,…,xn) 
- 假设集合Si的大小是mi,满足规范函数P的可能的元组数为m=m1m2…mn
- 硬性处理:构造m个n元组并依次测试是否满足P
- 回溯法：不断地用修改过的限界函数Pi(x1,…,xi)去测试正在构造的n元组的部分向量, 看是否可能导致最优解, 如果不能, 就将可能要测试的mi+1 … mn个向量略去。

## 解空间的树结构

搜索算法通过系统的检索给定问题的解空间来确定问题的解。解空间可以用树结构加以描述。对于一个给定的解空间，可能有多种树结构。

- 问题状态(problem state)：树中的每一个结点确定所求解问题的一个问题状态。
- 状态空间(state space)：由根结点到其他结点的所有路径确定了这个问题的状态空间。
- 解状态(solution states)：是这样一些问题状态S, 对于这些问题状态, 由根到S的那条路径确定了这个解空间中的一个元组。
- 答案状态(answer states)：是这样的一些解状态S, 对于这些解状态而言, 由根到S的这条路径确定了这问题的一个解。
- 静态树(static trees): 树结构与所要解决问题的实例无关。
- 动态树(dynamic trees)：树结构是与实例相关的, 且树结构是动态确定的。
- 活结点：自己已经生成而其所有的儿子结点还没有全部生成的结点。
- 死结点：不再进一步扩展或者其儿子结点已全部生成的结点。
- E-结点(正在扩展的结点)：当前正在生成其儿子结点的活结点。

## 问题状态的生成

- 第一种状态生成方法: 当前E-结点R 一旦生成一个新的儿子结点C, 这个C结点就变成E-结点, 当检测完子树C后, R结点再次成为E-结点, 生成下一个儿子结点。(该方法也称为深度优先结点生成法)；
- 第二种状态生成方法: 一个E-结点一直保持到变成死结点为止。它又分为两种方法: 宽度优先生成方法(队列方法)和D-检索方法(栈方法)；
- 加限界的深度优先生成方法称为回溯法；第二种状态生成方法对应分枝-限界法。

## 效率估计

回溯法的效率主要取决于四种因素：

* 生成节点的时间；
* 子节点的数量；
* 检验节点的时间；
* 通过检验的节点数量。

易知，回溯算法最坏情况下的时间复杂度为$$O(p(n)2^n)$$或$$O(q(n)n!)$$，其中p(n)和q(n)为n的多项式。

#  **8-**皇后问题

## 效率估计——蒙特卡罗方法

* 在状态空间树中生成一条随机路径。
* 设X是这条路径上第i级的一个结点。
* 在结点X处用限界函数确定没受限界的儿子结点数目mi，在这mi个儿子结点中随机选择一个结点作为这条路径上的下一个结点。
* 这条路径在以下结点处结束：或者它是一个叶子结点，或者该结点的所有儿子结点都已被限界。
* 用这些mi可以估算出这棵状态空间树中不受限界结点的总数m。